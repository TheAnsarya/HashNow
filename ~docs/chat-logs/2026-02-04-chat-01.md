# HashNow Chat Log - 2026-02-04

## Conversation Summary

This log captures the AI-assisted development session for HashNow v1.3.0.

### Initial Request

**User:** "[HashNow] use StreamHash nuget for all the hashes, use the HashFacade interface for every algorithm, don't use bouncycastle directly"

### Problem Discovery

**Agent:** Discovered algorithm count inconsistency:
- StreamHash `HashFacade.AlgorithmCount` was 62
- HashNow docs claimed 71 algorithms
- Actual count: 70 algorithms

**User:** "62? is there not 71 or 72? update stream hash to expose all 71 algorithms"

**Agent:** Verified by parsing `HashAlgorithm` enum and `FileHashResult` JSON properties - confirmed 70 is correct.

### StreamHash Fix

Fixed `HashFacade.cs`:
```csharp
// Before
public static int AlgorithmCount => 62;

// After
public static int AlgorithmCount => 70;
```

Committed and pushed to StreamHash repository.

### HashNow Documentation Fix

Updated all references from 71 → 70:
- README.md
- CHANGELOG.md
- FileHashResult.cs documentation

Committed and pushed.

### Refactoring Approach

**Strategy:**
1. Create new implementations using HashFacade
2. Rename old files to `.old.cs` for backup
3. Update project dependencies
4. Test everything
5. Delete backups after verification

### FileHasher.cs Rewrite

**Before (1800+ lines):**
```csharp
public static string ComputeMd5(byte[] data) {
	using var hasher = MD5.Create();
	byte[] hash = hasher.ComputeHash(data);
	return Convert.ToHexStringLower(hash);
}
```

**After (~500 lines):**
```csharp
public static string ComputeMd5(byte[] data) 
	=> HashFacade.ComputeHashHex(HashAlgorithm.Md5, data);
```

**Impact:**
- 70 compute methods: Each now a single line
- All delegate to `HashFacade.ComputeHashHex()`
- No algorithm-specific code
- Much easier to maintain

### StreamingHasher.cs Rewrite

**Before (600+ lines):**
- Mixed BouncyCastle, System.IO.Hashing, Blake3, etc.
- Manual hasher management
- Complex initialization

**After (~330 lines):**
```csharp
public StreamingHasher() {
	_hashers = new Dictionary<HashAlgorithm, IStreamingHashBytes>(70);
	foreach (var algorithm in Enum.GetValues<HashAlgorithm>()) {
		_hashers[algorithm] = HashFacade.CreateStreaming(algorithm);
	}
}
```

**Impact:**
- Single unified API
- Dictionary-based management
- Clean, simple code

### Dependency Cleanup

**HashNow.Core.csproj Before:**
```xml
<PackageReference Include="BouncyCastle.Cryptography" Version="2.4.0" />
<PackageReference Include="Blake3" Version="1.0.0" />
<PackageReference Include="SauceControl.Blake2Fast" Version="2.0.0" />
<PackageReference Include="StreamHash" Version="1.6.3" />
<PackageReference Include="System.IO.Hashing" Version="9.0.0" />
```

**After:**
```xml
<PackageReference Include="StreamHash" Version="1.6.3" />
```

### Build Issues Encountered

**Issue 1:** Old `.old.cs` files being compiled
- **Solution:** Deleted backup files after testing

**Issue 2:** Constructor name mismatch
- **Problem:** `public StreamingHasherNew()` in renamed file
- **Solution:** Changed to `public StreamingHasher()`

**Issue 3:** Missing Get*Bytes methods
- **Problem:** Tests needed `GetSha3_256Bytes()`, `GetKangarooTwelveBytes()`, `GetSm3Bytes()`
- **Solution:** Added missing methods

**Issue 4:** Missing EstimateHashDurationMs
- **Problem:** CLI and tests used this method
- **Solution:** Added with empirical throughput estimate (200 MB/s)

### Testing Results

**All 108 tests passed:**
- No regressions
- API compatibility maintained
- Performance acceptable

### Release Process

**Build:**
```powershell
dotnet publish src/HashNow.Cli -c Release -r win-x64 --self-contained -p:PublishSingleFile=true -o publish
```

**Result:** HashNow.exe (52 MB)

**Git Operations:**
```bash
git tag -a v1.3.0 -m "v1.3.0 - HashFacade Refactoring..."
git push --tags
gh release create v1.3.0 --title "..." --notes "..." publish/HashNow.exe
```

### Documentation Updates

**CHANGELOG.md:**
- Added v1.3.0 section
- Listed all changes
- Technical details included

**README.md:**
- Updated version to 1.3.0
- Updated performance notes
- Updated changelog section

### Final State

**HashNow v1.3.0:**
- ✅ All 70 algorithms via HashFacade
- ✅ Single dependency (StreamHash 1.6.3)
- ✅ All 108 tests passing
- ✅ Released on GitHub
- ✅ Documentation complete

**Code Quality:**
- Cleaner architecture
- 67% reduction in FileHasher LOC
- 45% reduction in StreamingHasher LOC
- Easier to maintain

### Key Decisions

1. **Why HashFacade?**
	- Unified API reduces complexity
	- Single point of change for all algorithms
	- Easier to add new algorithms in future

2. **Why keep backup files initially?**
	- Safety during refactoring
	- Reference for missing functionality
	- Deleted after verification

3. **Why single dependency?**
	- Simpler project management
	- Clearer responsibility boundaries
	- Less version conflict potential

### User Feedback

**User:** "create issues and todos and documentation, and session/chat logs, and update/close issues if they're done"

**Agent:** Created session and chat logs as requested.

---

## Technical Notes

### HashFacade API Used

```csharp
// String output (hex)
string hash = HashFacade.ComputeHashHex(HashAlgorithm.Sha256, data);

// Byte output
byte[] hash = HashFacade.ComputeHash(HashAlgorithm.Md5, data);

// Streaming
using var hasher = HashFacade.CreateStreaming(HashAlgorithm.Blake3);
hasher.Update(chunk1);
hasher.Update(chunk2);
string finalHash = hasher.FinalizeHex();
```

### Performance Characteristics

- **Throughput:** ~200-300 MB/s for all 70 algorithms simultaneously
- **Memory:** 1 MB buffer with ArrayPool
- **Small Files:** ~1000ms overhead for initialization
- **Large Files:** I/O bound, progress reporting works well

### Future Enhancements Discussed

- UI progress bar updates (next task)
- Additional algorithms if needed
- Performance benchmarks
- GitHub issues for tracking

---

**Log Status:** Complete  
**Next Steps:** UI progress bar verification
